% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/netAnalyze.R
\name{netAnalyze}
\alias{netAnalyze}
\title{Microbiome Network Analysis}
\usage{
netAnalyze(net,
           # Centrality related:
           centrLCC = TRUE,
           weightDeg = FALSE,
           normDeg = TRUE,
           normBetw = TRUE,
           normClose = TRUE,
           normEigen = deprecated(),
           
           # Cluster related:
           clustMethod = NULL,
           clustPar = NULL,
           clustPar2 = NULL,
           weightClustCoef = TRUE,
           
           # Hub related:
           hubPar = "eigenvector",
           hubQuant = 0.95,
           lnormFit = FALSE,
           
           # Graphlet related:
           graphlet = TRUE,
           orbits = c(0, 2, 5, 7, 8, 10, 11, 6, 9, 4, 1),
           gcmHeat = TRUE,
           gcmHeatLCC = TRUE,
           
           # Further arguments:
           avDissIgnoreInf = FALSE,
           sPathAlgo = "dijkstra",
           sPathNorm = TRUE,
           normNatConnect = TRUE,
           connectivity = TRUE,
           verbose = 1
           )
}
\arguments{
\item{net}{object of class \code{microNet} (returned by 
\code{\link{netConstruct}}).}

\item{centrLCC}{logical indicating whether to compute centralities only 
for the largest connected component (LCC). If \code{TRUE} 
(default), centrality values of disconnected components are zero.}

\item{weightDeg}{logical. If \code{TRUE}, the weighted degree is used (see
\code{\link[igraph]{strength}}). Default is \code{FALSE}. 
Is automatically set to \code{TRUE} for a fully connected (dense) network.}

\item{normDeg, normBetw, normClose, normEigen}{logical. If \code{TRUE} 
(default for all measures), a normalized version of the respective 
centrality values is returned.}

\item{clustMethod}{character indicating the clustering algorithm. Possible
values are \code{"hierarchical"} for a hierarchical algorithm based on
dissimilarity values, or the clustering methods provided by the igraph
package (see \code{\link[igraph]{communities}} for possible methods).
Defaults to \code{"cluster_fast_greedy"} for association-based networks and
to \code{"hierarchical"} for sample similarity networks.}

\item{clustPar}{list with parameters passed to the clustering functions.
If hierarchical clustering is used, the parameters are passed to
\code{\link[stats]{hclust}} and \code{\link[stats]{cutree}} (default is 
\code{list(method = "average", k = 3)}.}

\item{clustPar2}{same as \code{clustPar} but for the second network. 
If \code{NULL} and \code{net} contains two networks,
\code{clustPar} is used for the second network as well.}

\item{weightClustCoef}{logical indicating whether (global) clustering 
coefficient should be weighted (\code{TRUE}, default) or unweighted 
(\code{FALSE}).}

\item{hubPar}{character vector with one or more elements (centrality 
measures) used for identifying hub nodes. Possible values are \code{degree},
\code{betweenness}, \code{closeness}, and \code{eigenvector}. If multiple
measures are given, hubs are nodes with highest centrality for all selected
measures. See details.}

\item{hubQuant}{quantile used for determining hub nodes. Defaults to 0.95.}

\item{lnormFit}{hubs are nodes with a centrality value above the 95\%
quantile of the fitted log-normal distribution (if \code{lnormFit = TRUE})
or of the empirical distribution of centrality values 
(\code{lnormFit = FALSE}; default).}

\item{graphlet}{logical. If \code{TRUE} (default), graphlet-based network 
properties are computed: orbit counts as defined by \code{orbits} 
and the corresponding Graphlet Correlation Matrix (\code{gcm}).}

\item{orbits}{numeric vector with integers from 0 to 14 defining the orbits 
used for calculating the GCM. Minimum length is 2. 
Defaults to c(0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11), 
thus excluding redundant orbits such as the orbit o3.}

\item{gcmHeat}{logical indicating if a heatmap of the GCM(s) should be 
plotted. Default is \code{TRUE}.}

\item{gcmHeatLCC}{logical. The GCM heatmap is plotted for the LCC if 
\code{TRUE} (default) and for the whole network if \code{FALSE}.}

\item{avDissIgnoreInf}{logical indicating whether to ignore infinities when 
calculating the average dissimilarity. If \code{FALSE} (default), infinity 
values are set to 1.}

\item{sPathAlgo}{character indicating the algorithm used for computing
the shortest paths between all node pairs. \code{\link[igraph]{distances}} 
(igraph) is used for shortest path calculation. 
Possible values are: "unweighted", "dijkstra" (default), "bellman-ford", 
"johnson", or "automatic" (the fastest suitable algorithm is used). The 
shortest paths are needed for the average (shortest) path length and 
closeness centrality.}

\item{sPathNorm}{logical. If \code{TRUE} (default), shortest paths are 
normalized by average dissimilarity (only connected nodes are considered),  
i.e., a path is interpreted as steps with average dissimilarity. 
If \code{FALSE}, the shortest path is the minimum sum of dissimilarities 
between two nodes.}

\item{normNatConnect}{logical. If \code{TRUE} (default), the normalized 
natural connectivity is returned.}

\item{connectivity}{logical. If \code{TRUE} (default), edge and vertex 
connectivity are calculated. Might be disabled to reduce execution time.}

\item{verbose}{integer indicating the level of verbosity. Possible values:
\code{"0"}: no messages, \code{"1"}: only important messages,
\code{"2"}(default): all progress messages are shown. Can also be logical.}
}
\value{
An object of class \code{microNetProps} containing the following
  elements: \tabular{ll}{
  \code{lccNames1, lccNames2}\tab Names of nodes in the largest connected 
  component(s).\cr
  \code{compSize1, compSize2}\tab Matrix/matrices with component sizes (1st 
  row: sizes; 2nd row: number of components with the respective size)\cr
  \code{clustering}\tab Determined clusters in the whole network (and 
  corresponding trees if hierarchical clustering is used)\cr
  \code{clusteringLCC}\tab Clusters (and optional trees) of the
  largest connected component.\cr
  \code{centralities}\tab Centrality values\cr
  \code{hubs}\tab Names of hub nodes\cr
  \code{globalProps}\tab Global network properties of the whole network.\cr
  \code{globalPropsLCC}\tab Global network properties of the largest 
  component.\cr
  \code{graphlet}\tab Graphlet-based properties (orbit counts and GCM).\cr
  \code{graphletLCC}\tab Graphlet-based properties of the largest connected 
  component.\cr
  \code{paramsProperties}\tab Given parameters used for network analysis\cr
  \code{paramsNetConstruct}\tab Parameters used for network construction 
  (inherited from \code{\link{netConstruct}}).\cr
  \code{input}\tab Input inherited from \code{\link{netConstruct}}.\cr
  \code{isempty}\tab Indicates whether network(s) is/are empty.
  }
}
\description{
Determine network properties for objects of class
  \code{microNet}.
}
\details{
\strong{Definitions:}\cr
  \describe{
  \item{(Connected) Component}{Subnetwork where any two nodes are connected 
  by a path.}
  \item{Number of components}{Number of connected components. Since a single 
  node is connected to itself by the trivial path, each single node is a 
  component.}
  \item{Largest connected component (LCC)}{The connected component with 
  highest number of nodes.}
  \item{Shortest paths}{Computed using \code{\link[igraph]{distances}}. The 
  algorithm is defined via \code{sPathAlgo}. Normalized shortest paths (if 
  \code{sPathNorm} is \code{TRUE}) are calculated by dividing the shortest 
  paths by the average dissimilarity (see below).}
  }
  \strong{Global network properties:}\cr
  \describe{
  \item{Relative LCC size}{= (# nodes in the LCC) / (# nodes in the complete 
  network)}
  \item{Clustering Coefficient}{The weighted (global) clustering coefficient 
  is the arithmetic mean of the local clustering coefficient defined by 
  Barrat et al. (computed by \code{\link[igraph]{transitivity}} with 
  type = "barrat"), where NAs are ignored. \cr 
  The unweighted (global) clustering coefficient is computed using 
  \code{\link[igraph]{transitivity}} with type = "global".}
  \item{Modularity}{The modularity score for the determined clustering is 
  computed using \code{\link[igraph]{modularity.igraph}}.}
  \item{Positive edge percentage}{Percentage of edges with positive estimated
  association of the total number of edges.}
  \item{Edge density}{Computed using \code{\link[igraph]{edge_density}}.}
  \item{Natural connectivity}{Computed using 
  \code{\link[pulsar]{natural.connectivity}}. The "norm" parameter is 
  defined by \code{normNatConnect}.}
  \item{Vertex / Edge connectivity}{Computed using 
  \code{\link[igraph]{vertex_connectivity}} and 
  \code{\link[igraph]{edge_connectivity}}. Both equal zero for a 
  disconnected network.}
  \item{Average dissimilarity}{Computed as the mean of dissimilarity values 
  (lower triangle of \code{dissMat}). By \code{avDissIgnoreInf} is specified 
  whether to ignore infinite dissimilarities. The average dissimilarity of an
  empty network is 1.}
  \item{Average path length}{Computed as the mean of shortest paths 
  (normalized or unnormalized). The av. path length of an empty network is 1.}
  }
  \strong{Clustering algorithms:}\cr
  \describe{
  \item{Hierarchical clustering}{Based on dissimilarity values. Computed 
  using \code{\link[stats]{hclust}} and \code{\link[stats]{cutree}}.}
  \item{cluster_optimal}{Modularity optimization. See 
  \code{\link[igraph]{cluster_optimal}}.}
  \item{cluster_fast_greedy}{Fast greedy modularity optimization. See 
  \code{\link[igraph]{cluster_fast_greedy}}.}
  \item{cluster_louvain}{Multilevel optimization of modularity. See 
  \code{\link[igraph]{cluster_louvain}}.}
  \item{cluster_edge_betweenness}{Based on edge betweenness. Dissimilarity
  values are used. See \code{\link[igraph]{cluster_edge_betweenness}}.}
  \item{cluster_leading_eigen}{Based on leading eigenvector of the community
  matrix. See \code{\link[igraph]{cluster_leading_eigen}}.}
  \item{cluster_spinglass}{Find communities via spin-glass model and 
  simulated annealing. See \code{\link[igraph]{cluster_spinglass}}.}
  \item{cluster_walktrap}{Find communities via short random walks. See
  \code{\link[igraph]{cluster_walktrap}}.}
  }
  \strong{Hubs:}\cr
  Hubs are nodes with highest centrality values for one or more
  centrality measures. The "highest values" regarding a centrality
  measure are defined as values lying above a certain quantile (defined by
  \code{hubQuant}) either of the empirical distribution of the centralities 
  (if \code{lnormFit = FALSE}) or of the fitted log-normal distribution 
  (if \code{lnormFit = TRUE}; \code{\link[MASS]{fitdistr}} is used for 
  fitting). The quantile is set using \code{hubQuant}.\cr
  If \code{clustPar} contains multiple measures, the centrality values of a 
  hub node must be above the given quantile for all measures at the same time.
  \cr\cr
  \strong{Centrality measures:}\cr
  Via \code{centrLCC} is decided whether centralities should be calculated 
  for the whole network or only for the largest connected component. In the 
  latter case (\code{centrLCC = FALSE}), nodes outside the LCC have a 
  centrality value of zero.
  \describe{
  \item{Degree}{The unweighted degree (normalized and unnormalized) is 
  computed using \code{\link[igraph]{degree}}, and the weighted degree 
  using \code{\link[igraph]{strength}}.}
  \item{Betweenness centrality}{The unnormalized and normalized betweenness 
  centrality is computed using \code{\link[igraph]{betweenness}}.}
  \item{Closeness centrality}{Unnormalized: closeness = sum(1/shortest paths)
  \cr Normalized: closeness_unnorm = closeness / (# nodes – 1)}
  \item{Eigenvector centrality}{If \code{centrLCC == FALSE} and the network 
  consists of more than one components: The eigenvector centrality (EVC) is 
  computed for each component separately (using 
  \code{\link[igraph]{eigen_centrality}}) and scaled according to component 
  size to overcome the fact that nodes in smaller components have a higher 
  EVC. If \code{normEigen == TRUE}, the EVC values are divided by the maximum 
  EVC value. EVC of single nodes is zero.\cr\cr
  Otherwise, the EVC is computed for the LCC using 
  \code{\link[igraph]{eigen_centrality}} (scale argument is set according to 
  \code{normEigen}).}
  }
  \strong{Graphlet-based properties:}\cr
  \describe{
  \item{Orbit counts}{Count of node orbits in graphlets with 2 to 4 nodes. 
  See Hocevar and Demsar (2016) for details. The \code{\link[orca]{count4}} 
  function from \code{orca} package is used for orbit counting.
  }
  \item{Graphlet Correlation Matrix (GCM)}{Matrix with Spearman's 
  correlations between the network's (non-redundant) node orbits 
  (Yaveroglu et al., 2014).}
  }
  By default, only the 11 non-redundant orbits are used. These are grouped 
  according to their role: orbit 0 represents the degree, orbits (2, 5, 7) 
  represent nodes within a chain, orbits (8, 10, 11) represent nodes in a 
  cycle, and orbits (6, 9, 4, 1) represent a terminal node.
}
\examples{
knitr::opts_chunk$set(fig.width = 8, fig.height = 8)

# Load data sets from American Gut Project (from SpiecEasi package)
data("amgut1.filt")

# Network construction
amgut_net1 <- netConstruct(amgut1.filt, measure = "pearson",
                           filtTax = "highestVar",
                           filtTaxPar = list(highestVar = 50),
                           zeroMethod = "pseudoZO", normMethod = "clr",
                           sparsMethod = "threshold", thresh = 0.4)

# Network analysis

# Using eigenvector centrality as hub score
amgut_props1 <- netAnalyze(amgut_net1, clustMethod = "cluster_fast_greedy",
                           hubPar = "eigenvector")

summary(amgut_props1, showCentr = "eigenvector", numbNodes = 15L, digits = 3L)

# Using degree, betweenness and closeness centrality as hub scores
amgut_props2 <- netAnalyze(amgut_net1, clustMethod = "cluster_fast_greedy",
                           hubPar = c("degree", "betweenness", "closeness"))

summary(amgut_props2, showCentr = "all",  numbNodes = 5L, digits = 5L)

# Calculate centralities only for the largest connected component
amgut_props3 <- netAnalyze(amgut_net1, centrLCC = TRUE,
                           clustMethod = "cluster_fast_greedy",
                           hubPar = "eigenvector")

summary(amgut_props3, showCentr = "none", clusterLCC = TRUE)

# Network plot
plot(amgut_props1)
plot(amgut_props2)
plot(amgut_props3)

#----------------------------------------------------------------------------
# Plot the GCM heatmap
plotHeat(mat = amgut_props1$graphletLCC$gcm1,
         pmat = amgut_props1$graphletLCC$pAdjust1,
         type = "mixed",
         title = "GCM",
         colorLim = c(-1, 1),
         mar = c(2, 0, 2, 0))
# Add rectangles
graphics::rect(xleft   = c( 0.5,  1.5, 4.5,  7.5),
               ybottom = c(11.5,  7.5, 4.5,  0.5),
               xright  = c( 1.5,  4.5, 7.5, 11.5),
               ytop    = c(10.5, 10.5, 7.5,  4.5),
               lwd = 2, xpd = NA)

text(6, -0.2, xpd = NA,
     "Significance codes:  ***: 0.001;  **: 0.01;  *: 0.05")

#----------------------------------------------------------------------------
# Dissimilarity-based network (where nodes are subjects)
amgut_net4 <- netConstruct(amgut1.filt, measure = "aitchison",
                           filtSamp = "highestFreq",
                           filtSampPar = list(highestFreq = 30),
                           zeroMethod = "multRepl", sparsMethod = "knn")

amgut_props4 <- netAnalyze(amgut_net4, clustMethod = "hierarchical",
                           clustPar = list(k = 3))

plot(amgut_props4)
}
\references{
Hocevar T, Demsar J (2016). “Computation of graphlet orbits for nodes and 
  edges in sparse graphs.” \emph{Journal of Statistical Software}, 
  71, 1–24.\cr\cr
  Yaveroglu ON, Malod-Dognin N, Davis D, Levnajic Z, Janjic V, Karapandza R, 
  Stojmirovic A, Przulj N (2014). “Revealing the hidden language of complex 
  networks.” \emph{Scientific reports}, 4(1), 1–9.
}
\seealso{
\code{\link{netConstruct}} for network construction,
  \code{\link{netCompare}} for network comparison,
  \code{\link{diffnet}} for constructing differential networks,
  \code{\link{plot.microNetProps}} for the plot method, and
  \code{\link{summary.microNetProps}} for the summary method.
}
